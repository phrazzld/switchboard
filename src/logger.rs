//! Logging configuration and setup
//!
//! This module handles the initialization and configuration of the tracing system
//! used for structured logging throughout the application with support for
//! dual outputs (file and stdout).
//!
//! # Dual-Output Logging
//!
//! The logging system is designed to output logs to two destinations simultaneously:
//!
//! 1. **File Output:** JSON-formatted logs written to a file with daily rotation
//!    - Uses non-blocking I/O to prevent application slowdowns
//!    - Configurable minimum log level via `log_file_level`
//!    - JSON format for easy parsing and analysis
//!    - Daily rotation appends the date to filenames (e.g., `switchboard.log.2023-04-24`)
//!
//! 2. **Stdout Output:** Configurable format for console display
//!    - Choose between human-readable "pretty" format or JSON
//!    - Configurable minimum log level via `log_stdout_level`
//!
//! # Security Features
//!
//! The logging system includes several security features:
//!
//! - **Path validation** to prevent path traversal attacks (e.g., via `../` in paths)
//! - **Reserved path protection** to prevent writing logs to system directories
//! - **Permission validation** to ensure the target directory is writable
//! - **Path canonicalization** to resolve and validate absolute paths
//!
//! # Configuration
//!
//! Logging is configured through the following environment variables:
//!
//! - `LOG_FILE_PATH`: Path to the log file (default: "./switchboard.log")
//! - `LOG_FILE_LEVEL`: Minimum level for file logs (default: "debug")
//! - `LOG_LEVEL`: Minimum level for stdout logs (default: "info")
//! - `LOG_FORMAT`: Format for stdout logs ("pretty" or "json", default: "pretty")
//! - `LOG_BODIES`: Whether to log request/response bodies (default: "true")
//! - `LOG_MAX_BODY_SIZE`: Maximum size for logged bodies in bytes (default: "20480")
//!
//! # JSON Log Format
//!
//! When logging to files (or stdout with JSON format), logs follow this schema:
//!
//! ```json
//! {
//!   "timestamp": "2023-04-24T12:34:56.789012Z",  // ISO-8601 UTC timestamp
//!   "level": "INFO",                             // Log level
//!   "fields": {                                  // Structured fields
//!     "message": "Log message here",             // The log message
//!     "field1": "value1",                        // Additional structured fields
//!     "field2": 123                              // Numeric values preserved as numbers
//!   },
//!   "target": "switchboard::module_name",        // Source module
//!   "span": {                                    // Span information (if present)
//!     "name": "span_name"
//!   },
//!   "spans": [                                   // Span hierarchy (if present)
//!     {"name": "span_name"}
//!   ]
//! }
//! ```
//!
//! # Non-Blocking I/O
//!
//! File logging uses non-blocking I/O through the `tracing_appender` crate. This prevents
//! the application from blocking when writing logs to disk, which is important for maintaining
//! performance under high loads. The `WorkerGuard` returned by `init_tracing()` must be kept
//! alive for the duration of the application to ensure logs are properly flushed.

use crate::config::Config;
use directories::ProjectDirs;
use std::env;
use std::io;
#[cfg(target_family = "unix")]
use std::os::unix::fs::MetadataExt;
use std::path::{Path, PathBuf};
use std::process;
#[cfg(target_family = "unix")]
use std::process::Command;
use thiserror::Error;
use tracing::info;
use tracing_appender::non_blocking::WorkerGuard;
use tracing_appender::rolling;
use tracing_subscriber::{fmt as tracing_fmt, prelude::*, registry, EnvFilter};

/// Default base directory for logs
pub const DEFAULT_LOG_DIR: &str = "./logs";
/// Subdirectory for application logs
pub const APP_LOG_SUBDIR: &str = "app";
/// Subdirectory for test logs
pub const TEST_LOG_SUBDIR: &str = "test";
/// System log directory for Unix-like platforms
#[cfg(target_family = "unix")]
pub const SYSTEM_LOG_DIR: &str = "/var/log/switchboard";
/// System log directory for Windows
#[cfg(target_family = "windows")]
pub const SYSTEM_LOG_DIR: &str = "C:\\ProgramData\\Switchboard\\Logs";

/// Represents the environment in which the application is running
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogEnvironment {
    /// Development environment (local development)
    Development,
    /// User-level installation (installed for a specific user)
    UserInstallation,
    /// System-level service (running as a system service)
    SystemService,
}

/// Type of logs being generated by the application
///
/// This enum distinguishes between application logs (normal operation) and
/// test logs (generated during test runs), allowing them to be stored in
/// separate directories.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LogType {
    /// Normal application logs (production, development)
    Application,
    /// Logs generated during test runs
    Test,
}

/// Resolves log file paths based on environment, configuration, and log type
///
/// This struct is responsible for determining the appropriate log directory
/// and file path based on:
/// - The current execution environment (development, user installation, or system service)
/// - The application configuration
/// - The type of logs being generated (application or test)
///
/// It handles the complexity of organizing logs in a consistent directory structure
/// across different deployment environments, following platform-specific conventions.
#[derive(Debug, Clone)]
pub struct LogPathResolver {
    /// Base directory for logs, determined by environment
    base_dir: PathBuf,
    /// Type of logs (application or test)
    log_type: LogType,
    /// Name of the log file (without directory path)
    file_name: String,
}

impl LogPathResolver {
    /// Creates a new LogPathResolver instance
    ///
    /// Initializes a path resolver based on the current environment and provided configuration.
    /// The resolver will use the appropriate base directory for the detected environment,
    /// and will be configured for either application or test logs.
    ///
    /// # Arguments
    ///
    /// * `config` - Reference to the application configuration
    /// * `log_type` - The type of logs to handle (Application or Test)
    ///
    /// # Returns
    ///
    /// A new LogPathResolver instance configured for the specified log type and
    /// current environment.
    ///
    /// # Examples
    ///
    /// ```
    /// use switchboard::config::Config;
    /// use switchboard::logger::{LogPathResolver, LogType};
    ///
    /// // Create a test configuration
    /// let config = Config {
    ///     // ... config fields ...
    ///     log_file_path: "./switchboard.log".to_string(),
    ///     // ... other fields ...
    ///     # port: "8080".to_string(),
    ///     # anthropic_api_key: "test-key".to_string(),
    ///     # anthropic_target_url: "https://example.com".to_string(),
    ///     # log_stdout_level: "info".to_string(),
    ///     # log_format: "pretty".to_string(),
    ///     # log_bodies: true,
    ///     # log_file_level: "debug".to_string(),
    ///     # log_max_body_size: 20480,
    /// };
    ///
    /// // Create a resolver for application logs
    /// let app_resolver = LogPathResolver::new(&config, LogType::Application);
    /// ```
    pub fn new(config: &Config, log_type: LogType) -> Self {
        // Detect the current environment
        let environment = detect_environment();

        // Get the appropriate base directory for this environment
        let base_dir = get_environment_log_directory(environment);

        // Extract just the filename from the configured log path
        let file_name = Path::new(&config.log_file_path)
            .file_name()
            .map(|name| name.to_string_lossy().to_string())
            .unwrap_or_else(|| "switchboard.log".to_string());

        LogPathResolver {
            base_dir,
            log_type,
            file_name,
        }
    }
    
    /// Resolves the complete log file path and creates necessary directories
    ///
    /// This method:
    /// 1. Constructs the full path by combining:
    ///    - Base directory (determined by environment)
    ///    - Subdirectory (app/ or test/ based on log type)
    ///    - Filename
    /// 2. Creates the directory structure if it doesn't exist
    /// 3. Sets appropriate permissions based on platform
    ///
    /// # Returns
    ///
    /// * `Ok(PathBuf)` - The resolved absolute path if everything succeeds
    /// * `Err(LogInitError)` - Error details if directory creation or permission setting fails
    ///
    /// # Examples
    ///
    /// ```
    /// use switchboard::config::Config;
    /// use switchboard::logger::{LogPathResolver, LogType};
    ///
    /// // Create a test configuration
    /// let config = Config {
    ///     // ... config fields ...
    ///     log_file_path: "./switchboard.log".to_string(),
    ///     // ... other fields ...
    ///     # port: "8080".to_string(),
    ///     # anthropic_api_key: "test-key".to_string(),
    ///     # anthropic_target_url: "https://example.com".to_string(),
    ///     # log_stdout_level: "info".to_string(),
    ///     # log_format: "pretty".to_string(),
    ///     # log_bodies: true,
    ///     # log_file_level: "debug".to_string(),
    ///     # log_max_body_size: 20480,
    /// };
    ///
    /// // Create a resolver for application logs and resolve the path
    /// let app_resolver = LogPathResolver::new(&config, LogType::Application);
    /// let app_log_path = app_resolver.resolve().expect("Failed to resolve log path");
    /// println!("App logs will be stored at: {}", app_log_path.display());
    /// ```
    pub fn resolve(&self) -> Result<PathBuf, LogInitError> {
        // Determine the appropriate subdirectory based on log type
        let subdir = match self.log_type {
            LogType::Application => APP_LOG_SUBDIR,
            LogType::Test => TEST_LOG_SUBDIR,
        };
        
        // Construct the directory path by combining base dir and subdirectory
        let dir_path = self.base_dir.join(subdir);
        
        // Create the directory if it doesn't exist
        if !dir_path.exists() {
            if let Err(e) = std::fs::create_dir_all(&dir_path) {
                return Err(LogInitError::DirectoryCreationFailed {
                    path: dir_path.display().to_string(),
                    source: e,
                });
            }
            
            // Set directory permissions (platform-specific)
            #[cfg(target_family = "unix")]
            {
                use std::fs::Permissions;
                use std::os::unix::fs::PermissionsExt;
                
                // Set directory permissions to 0o750 (rwxr-x---)
                if let Err(e) = std::fs::set_permissions(&dir_path, Permissions::from_mode(0o750)) {
                    return Err(LogInitError::PermissionIssue {
                        path: dir_path.display().to_string(),
                        reason: format!("Failed to set directory permissions: {}", e),
                    });
                }
            }
            
            // Windows: default permissions are generally appropriate
            // But we could add ACL tightening here if needed in the future
            #[cfg(target_family = "windows")]
            {
                // Windows default permissions for newly created directories are
                // typically inherited from parent, which is usually appropriate
                // For advanced ACL support, we would need to use the windows-rs crate
            }
        }
        
        // Combine directory path with filename to get the full path
        let file_path = dir_path.join(&self.file_name);
        
        // Return the resolved path
        Ok(file_path)
    }
}

/// Error type for logging initialization failures
#[derive(Debug, Error)]
pub enum LogInitError {
    /// Failed to create the log directory
    #[error("Failed to create log directory at {path}: {source}")]
    DirectoryCreationFailed {
        /// Path to the directory that could not be created
        path: String,
        /// Source IO error
        #[source]
        source: io::Error,
    },

    /// Failed to parse log level
    #[error("Failed to parse log level filter: {0}")]
    FilterParseError(String),

    /// Base path issue for logging
    #[error("Invalid log file path: {0}")]
    InvalidPath(String),

    /// Path traversal attempt detected in log path
    #[error("Path traversal attempt detected in log path: {0}")]
    PathTraversalAttempt(String),

    /// Reserved system path not allowed for logging
    #[error("Reserved system path not allowed for logging: {0}")]
    ReservedSystemPath(String),

    /// Permission issue with log directory
    #[error("Permission issue with log directory at {path}: {reason}")]
    PermissionIssue {
        /// Path to the directory with permission issues
        path: String,
        /// Reason for the permission issue
        reason: String,
    },

    /// Path canonicalization error
    #[error("Failed to canonicalize path {path}: {source}")]
    PathCanonicalizationError {
        /// Path that could not be canonicalized
        path: String,
        /// Source IO error
        #[source]
        source: io::Error,
    },
}

/// Validate a log file path for security and usability concerns, creating directories as needed
///
/// This function performs comprehensive validation on a log file path to ensure it:
/// - Does not contain path traversal attempts
/// - Is not a reserved system path
/// - Has appropriate permissions for logging
/// - Can be canonicalized to an absolute path
/// - Creates required directory structure if it doesn't exist
///
/// The function now supports the new directory structure using `DEFAULT_LOG_DIR` and the
/// appropriate subdirectory (`APP_LOG_SUBDIR` or `TEST_LOG_SUBDIR`).
///
/// # Arguments
/// * `path_str` - The string path to validate, can be a file or directory path
///
/// # Returns
/// * `Ok(PathBuf)` - The canonicalized absolute path if validation passes
/// * `Err(LogInitError)` - Specific error if validation fails
///
/// # Security Considerations
/// This validation helps prevent common security issues:
/// - Path traversal: Prevents writing to unexpected locations via `../` sequences
/// - System path protection: Prevents overwriting system files in locations like `/bin`, `/etc`, etc.
/// - Permission verification: Ensures logs can actually be written
///
/// # Errors
/// Returns detailed error types for different validation failures:
/// - `LogInitError::InvalidPath` - Path is empty or has invalid format
/// - `LogInitError::PathTraversalAttempt` - Path contains `../` sequences
/// - `LogInitError::ReservedSystemPath` - Path points to a reserved system directory
/// - `LogInitError::PermissionIssue` - Directory exists but is not writable
/// - `LogInitError::PathCanonicalizationError` - Path cannot be canonicalized
/// - `LogInitError::DirectoryCreationFailed` - Directory structure couldn't be created
///
/// # Examples
///
/// ```
/// # use switchboard::logger::validate_log_path;
/// // Valid path in a temporary directory
/// let valid_path = std::env::temp_dir().join("app.log").to_string_lossy().to_string();
/// assert!(validate_log_path(&valid_path).is_ok());
///
/// // Invalid path (path traversal attempt)
/// let invalid_path = "../etc/passwd";
/// assert!(validate_log_path(invalid_path).is_err());
/// ```
pub fn validate_log_path(path_str: &str) -> Result<PathBuf, LogInitError> {
    // Check for empty path
    if path_str.is_empty() {
        return Err(LogInitError::InvalidPath(
            "Log file path cannot be empty".to_string(),
        ));
    }

    let path = Path::new(path_str);

    // Check if path contains parent directory components that could lead to traversal
    if path_str.contains("../") || path_str.contains("..\\") {
        return Err(LogInitError::PathTraversalAttempt(format!(
            "Path contains parent directory traversal sequences: {}",
            path_str
        )));
    }

    // Determine if this is a directory path or a file path
    let is_directory_path = path_str.ends_with('/') || path_str.ends_with('\\');

    // If it's a directory path, we'll use it directly for directory checks
    // If it's a file path, we'll extract the directory and filename separately
    let (dir_path, file_name_opt) = if is_directory_path {
        // For directory paths, we use the path directly and have no filename
        (path, None)
    } else {
        // For file paths, extract filename and directory separately
        let file_name = match path.file_name() {
            Some(name) => name,
            None => {
                return Err(LogInitError::InvalidPath(format!(
                    "Invalid log file path (no filename): {}",
                    path_str
                )));
            }
        };

        // Get directory component
        let dir_path = path.parent().unwrap_or_else(|| Path::new("."));
        (dir_path, Some(file_name))
    };

    // Reserved system paths that should not be used for logging
    let reserved_paths = [
        #[cfg(target_family = "unix")]
        "/bin",
        #[cfg(target_family = "unix")]
        "/sbin",
        #[cfg(target_family = "unix")]
        "/usr/bin",
        #[cfg(target_family = "unix")]
        "/usr/sbin",
        #[cfg(target_family = "unix")]
        "/etc",
        #[cfg(target_family = "unix")]
        "/dev",
        #[cfg(target_family = "unix")]
        "/proc",
        #[cfg(target_family = "unix")]
        "/sys",
        #[cfg(target_family = "windows")]
        "C:\\Windows",
        #[cfg(target_family = "windows")]
        "C:\\Program Files",
        #[cfg(target_family = "windows")]
        "C:\\Program Files (x86)",
    ];

    // Try to canonicalize the path to resolve any . or .. components
    let canonical_path = match std::fs::canonicalize(dir_path) {
        Ok(p) => p,
        Err(e) => {
            // If the directory doesn't exist yet, that's ok - we'll create it later
            // Only return an error if it's not a NotFound error
            if e.kind() != io::ErrorKind::NotFound {
                return Err(LogInitError::PathCanonicalizationError {
                    path: dir_path.display().to_string(),
                    source: e,
                });
            }
            // For NotFound, we'll continue with the original path
            dir_path.to_path_buf()
        }
    };

    // Check if the path (without canonicalization) is a reserved system path
    // This is to catch paths that might not be able to be canonicalized
    let path_to_check = if canonical_path == dir_path.to_path_buf() {
        // If canonicalization didn't work (e.g., directory doesn't exist yet),
        // check the original path against reserved paths
        path_str.to_string()
    } else {
        // Otherwise, check the canonical path
        canonical_path.to_string_lossy().to_string()
    };

    for reserved in &reserved_paths {
        if path_to_check.starts_with(reserved) {
            return Err(LogInitError::ReservedSystemPath(format!(
                "Path '{}' is within a reserved system directory: {}",
                path_str, reserved
            )));
        }
    }

    // If base directory doesn't exist, create the needed structure
    let base_dir = if path_str.starts_with(DEFAULT_LOG_DIR) {
        PathBuf::from(DEFAULT_LOG_DIR)
    } else if path_str.contains(DEFAULT_LOG_DIR) {
        // This handles more complex paths that might include the default directory somewhere
        let parts: Vec<_> = path_str.split(DEFAULT_LOG_DIR).collect();
        if parts.len() >= 2 {
            PathBuf::from(format!("{}{}", parts[0], DEFAULT_LOG_DIR))
        } else {
            PathBuf::from(DEFAULT_LOG_DIR)
        }
    } else {
        // For paths that don't include our default directory, we'll just focus on the provided directory
        PathBuf::new()
    };

    // If we identified a valid base directory and it doesn't exist, create it
    if !base_dir.as_os_str().is_empty() && !base_dir.exists() {
        if let Err(e) = std::fs::create_dir_all(&base_dir) {
            return Err(LogInitError::DirectoryCreationFailed {
                path: base_dir.display().to_string(),
                source: e,
            });
        }
    }

    // Check for and create the app/test subdirectories if needed
    if base_dir.as_os_str().is_empty() {
        // No base directory was identified, so we can't create subdirectories
    } else if path_str.contains(APP_LOG_SUBDIR) {
        // Path contains app subdirectory
        let app_dir = base_dir.join(APP_LOG_SUBDIR);
        if !app_dir.exists() {
            if let Err(e) = std::fs::create_dir_all(&app_dir) {
                return Err(LogInitError::DirectoryCreationFailed {
                    path: app_dir.display().to_string(),
                    source: e,
                });
            }
        }
    } else if path_str.contains(TEST_LOG_SUBDIR) {
        // Path contains test subdirectory
        let test_dir = base_dir.join(TEST_LOG_SUBDIR);
        if !test_dir.exists() {
            if let Err(e) = std::fs::create_dir_all(&test_dir) {
                return Err(LogInitError::DirectoryCreationFailed {
                    path: test_dir.display().to_string(),
                    source: e,
                });
            }
        }
    }

    // If directory exists, check permissions
    if dir_path.exists() {
        // Try to check if we can write to this directory
        match std::fs::metadata(dir_path) {
            Ok(metadata) => {
                #[cfg(target_family = "unix")]
                {
                    // On Unix systems, check if directory is writable by the current user
                    let dir_mode = metadata.mode();
                    let uid = unsafe { libc::getuid() };
                    let gid = unsafe { libc::getgid() };

                    let owner_writable = (dir_mode & 0o200) != 0; // Check owner write permission
                    let group_writable = (dir_mode & 0o020) != 0; // Check group write permission
                    let world_writable = (dir_mode & 0o002) != 0; // Check world write permission

                    let is_owner = metadata.uid() == uid;
                    let is_group = metadata.gid() == gid;

                    let is_writable = (is_owner && owner_writable)
                        || (is_group && group_writable)
                        || world_writable;

                    if !is_writable {
                        return Err(LogInitError::PermissionIssue {
                            path: dir_path.display().to_string(),
                            reason: "Directory is not writable by the current user".to_string(),
                        });
                    }
                }

                // For other platforms, we'll try a more basic approach
                #[cfg(not(target_family = "unix"))]
                {
                    // Check if readonly
                    if metadata.permissions().readonly() {
                        return Err(LogInitError::PermissionIssue {
                            path: dir_path.display().to_string(),
                            reason: "Directory is read-only".to_string(),
                        });
                    }
                }
            }
            Err(e) => {
                // If we can't read metadata, that might be a permissions issue
                return Err(LogInitError::PermissionIssue {
                    path: dir_path.display().to_string(),
                    reason: format!("Failed to read directory metadata: {}", e),
                });
            }
        }
    } else if !is_directory_path {
        // If it's a file path and the parent directory doesn't exist, create it
        if let Err(e) = std::fs::create_dir_all(dir_path) {
            return Err(LogInitError::DirectoryCreationFailed {
                path: dir_path.display().to_string(),
                source: e,
            });
        }
    }

    // Construct the final path
    let result_path = if is_directory_path {
        // For directory paths, just use the canonical path directly
        canonical_path
    } else {
        // For file paths, combine canonical directory path with filename
        let mut path = canonical_path;
        if let Some(file_name) = file_name_opt {
            path.push(file_name);
        }
        path
    };

    Ok(result_path)
}

/// Initialize the tracing system for structured logging with dual output
///
/// Sets up the tracing subscriber with two output layers:
/// 1. **File Layer**: JSON-formatted logs with level filtering by `log_file_level`, using
///    non-blocking I/O and daily rotation.
/// 2. **Stdout Layer**: Configurable format (pretty or JSON) with level filtering by `log_stdout_level`.
///
/// This function handles:
/// - Validating log file paths for security (preventing path traversal, etc.)
/// - Creating log directories if they don't exist
/// - Setting up daily log rotation
/// - Configuring non-blocking file I/O
/// - Applying the appropriate filters based on log levels
/// - Setting up the correct output format for each destination
///
/// The function logs its own initialization with configuration details, which serves as
/// verification that logging is properly set up.
///
/// # Arguments
/// * `config` - The application configuration containing logging settings
///
/// # Returns
/// Returns a `Result` containing a `WorkerGuard` which **must be kept alive** for the duration
/// of the application, or a `LogInitError` if initialization fails.
/// If this guard is dropped, pending logs might not be flushed to disk. In a typical
/// application, store this guard in your main application struct or in the `main` function.
///
/// # Errors
/// This function will return an error if:
/// - The log directory cannot be created
/// - The log file path is invalid
/// - The log level filters cannot be parsed
///
/// # Examples
/// Basic initialization with default settings:
/// ```
/// # use switchboard::config::Config;
/// # use switchboard::logger;
/// # // Create a mock config for testing instead of using global config
/// # let mock_config = Config {
/// #     port: "8080".to_string(),
/// #     anthropic_api_key: "test-key".to_string(),
/// #     anthropic_target_url: "https://example.com".to_string(),
/// #     log_stdout_level: "info".to_string(),
/// #     log_format: "pretty".to_string(),
/// #     log_bodies: true,
/// #     log_file_path: "./switchboard.log".to_string(),
/// #     log_file_level: "debug".to_string(),
/// #     log_max_body_size: 20480,
/// # };
/// // Initialize logging and keep the guard alive
/// let _guard = logger::init_tracing(&mock_config).expect("Failed to initialize logging");
///
/// // Your application code here...
///
/// // Guard automatically dropped at end of scope, flushing remaining logs
/// ```
///
/// Using JSON format for both outputs:
/// ```
/// # use switchboard::config::Config;
/// # use switchboard::logger;
/// let config = Config {
///     // ... other fields ...
///     log_stdout_level: "info".to_string(),
///     log_format: "json".to_string(), // Use JSON for stdout too
///     log_file_path: "./logs/switchboard.log".to_string(),
///     log_file_level: "debug".to_string(),
///     // ... other fields ...
///     # port: "8080".to_string(),
///     # anthropic_api_key: "test-key".to_string(),
///     # anthropic_target_url: "https://example.com".to_string(),
///     # log_bodies: true,
///     # log_max_body_size: 20480,
/// };
///
/// let _guard = logger::init_tracing(&config).expect("Failed to initialize logging");
/// ```
///
/// Different log levels for file and stdout:
/// ```
/// # use switchboard::config::Config;
/// # use switchboard::logger;
/// let config = Config {
///     // ... other fields ...
///     log_stdout_level: "warn".to_string(), // Only warnings and errors go to stdout
///     log_file_path: "./logs/switchboard.log".to_string(),
///     log_file_level: "trace".to_string(),  // Everything goes to the file
///     // ... other fields ...
///     # port: "8080".to_string(),
///     # anthropic_api_key: "test-key".to_string(),
///     # anthropic_target_url: "https://example.com".to_string(),
///     # log_format: "pretty".to_string(),
///     # log_bodies: true,
///     # log_max_body_size: 20480,
/// };
///
/// let _guard = logger::init_tracing(&config).expect("Failed to initialize logging");
/// ```
/// Detects the environment in which the application is running
///
/// This function uses platform-specific logic to detect the current execution environment:
///
/// - Development: Local development environment (default if no specific indicators found)
/// - UserInstallation: Installed for a specific user (e.g., in user's home directory)
/// - SystemService: Running as a system service (e.g., systemd service on Linux,
///   launchd service on macOS, or Windows Service)
///
/// # Platform-specific detection
///
/// ## Linux
/// - Checks if parent PID is 1
/// - Inspects `/proc/self/cgroup` for systemd
/// - Looks for systemd environment variables
///
/// ## macOS
/// - Checks if parent PID is 1
/// - Checks for controlling TTY
/// - Looks for XPC environment variables
///
/// ## Windows
/// - Uses Service Control Manager to check if running as a service
///
/// # Returns
///
/// Returns the detected `LogEnvironment` variant that best matches the current execution context.
///
/// # Examples
///
/// ```
/// use switchboard::logger::detect_environment;
///
/// let env = detect_environment();
/// println!("Running in {:?} environment", env);
/// ```
pub fn detect_environment() -> LogEnvironment {
    // Check if we're in a development-specific environment
    if cfg!(debug_assertions) || env::var("SWITCHBOARD_DEV").is_ok() {
        return LogEnvironment::Development;
    }

    // Platform-specific detection logic
    #[cfg(target_os = "linux")]
    {
        // Check if the parent process is init (PID 1)
        let ppid = unsafe { libc::getppid() };
        if ppid == 1 {
            return LogEnvironment::SystemService;
        }

        // Check cgroup to detect container or systemd service
        if let Ok(cgroups) = std::fs::read_to_string("/proc/self/cgroup") {
            // Systemd service units are typically in their own cgroup
            if cgroups.contains("systemd") || cgroups.contains("/system.slice/") {
                return LogEnvironment::SystemService;
            }
        }

        // Check for systemd-specific environment variables
        if env::var("INVOCATION_ID").is_ok() || env::var("JOURNAL_STREAM").is_ok() {
            return LogEnvironment::SystemService;
        }
    }

    #[cfg(target_os = "macos")]
    {
        // Check if the parent process is launchd (PID 1)
        let ppid = unsafe { libc::getppid() };
        if ppid == 1 {
            // Most likely a launchd service
            return LogEnvironment::SystemService;
        }

        // Check for XPC environment variables which indicate a launchd service
        if env::var("XPC_SERVICE_NAME").is_ok() {
            return LogEnvironment::SystemService;
        }

        // Check if there's no controlling terminal (typical for services)
        if let Ok(output) = Command::new("ps")
            .args(["-p", &process::id().to_string(), "-o", "tty="])
            .output()
        {
            let tty = String::from_utf8_lossy(&output.stdout).trim().to_string();
            if tty == "?" || tty.is_empty() {
                // No TTY often indicates a background service
                return LogEnvironment::SystemService;
            }
        }
    }

    #[cfg(target_os = "windows")]
    {
        // On Windows, detecting service status is more complex
        // For a proper implementation, we would use the Windows API
        // (QueryServiceStatusEx with Service Control Manager)

        // As a simpler heuristic, check environment variables that suggest a service
        if env::var("WINDIR").is_ok() && env::var("USERPROFILE").is_err() {
            // Services typically run in system context without user profile
            return LogEnvironment::SystemService;
        }

        // Check if running without a console, which is typical for services
        // This is a simplified approach; a full implementation would use Windows API
        if env::var("SESSIONNAME").is_err() {
            return LogEnvironment::SystemService;
        }
    }

    // Check for indications of a user installation (outside of development)
    // Here we're checking common patterns for user-installed applications
    if let Ok(home) = env::var("HOME") {
        if let Ok(exe_path) = env::current_exe() {
            if let Some(exe_str) = exe_path.to_str() {
                if exe_str.contains(&home) {
                    return LogEnvironment::UserInstallation;
                }
            }
        }
    }

    // Default if no specific environment is detected
    LogEnvironment::Development
}

/// Returns the XDG-compliant log directory for the application
///
/// This function uses the `directories` crate to retrieve the platform-specific
/// data directory according to XDG Base Directory Specification on Linux and
/// equivalent standards on macOS and Windows.
///
/// The function returns a path in the following format:
/// - Linux: `~/.local/share/switchboard/logs`
/// - macOS: `~/Library/Application Support/switchboard/logs`
/// - Windows: `C:\Users\<user>\AppData\Roaming\switchboard\logs`
///
/// # Returns
///
/// A `PathBuf` containing the XDG-compliant path for storing log files
///
/// # Examples
///
/// ```
/// use switchboard::logger::get_xdg_log_directory;
///
/// let xdg_path = get_xdg_log_directory();
/// println!("XDG log directory: {}", xdg_path.display());
/// ```
pub fn get_xdg_log_directory() -> PathBuf {
    // Use the directories crate to get platform-specific data directory
    // We use "switchboard" as the organization and application name
    if let Some(proj_dirs) = ProjectDirs::from("", "", "switchboard") {
        // Get the data directory and append logs subdirectory
        proj_dirs.data_dir().join("logs")
    } else {
        // Fallback to a reasonable default if we can't get XDG directory
        // This should be rare but could happen in constrained environments
        PathBuf::from(DEFAULT_LOG_DIR)
    }
}

/// Returns the appropriate log directory path based on the environment
///
/// This function determines the appropriate log directory path based on the
/// current execution environment:
///
/// - `Development`: Uses `DEFAULT_LOG_DIR` (./logs/)
/// - `UserInstallation`: Uses XDG-compliant directory from `get_xdg_log_directory`
/// - `SystemService`: Uses system log path (e.g., /var/log/switchboard/ on Unix)
///
/// # Arguments
///
/// * `environment` - The `LogEnvironment` value to determine the path for
///
/// # Returns
///
/// A `PathBuf` containing the appropriate log directory path
///
/// # Examples
///
/// ```
/// use switchboard::logger::{get_environment_log_directory, LogEnvironment};
///
/// // Get log directory for development environment
/// let dev_path = get_environment_log_directory(LogEnvironment::Development);
/// assert_eq!(dev_path.to_str().unwrap(), "./logs");
///
/// // Get log directory for user installation (XDG-compliant)
/// let user_path = get_environment_log_directory(LogEnvironment::UserInstallation);
/// // Path will vary by platform and username
/// ```
pub fn get_environment_log_directory(environment: LogEnvironment) -> PathBuf {
    match environment {
        LogEnvironment::Development => PathBuf::from(DEFAULT_LOG_DIR),
        LogEnvironment::UserInstallation => get_xdg_log_directory(),
        LogEnvironment::SystemService => PathBuf::from(SYSTEM_LOG_DIR),
    }
}

pub fn init_tracing(config: &Config) -> Result<WorkerGuard, LogInitError> {
    // Validate log file path with comprehensive security checks
    let validated_path = validate_log_path(&config.log_file_path)?;

    // Extract directory and filename from the validated path
    let log_dir = validated_path.parent().unwrap_or_else(|| Path::new("."));
    let log_file_name = validated_path.file_name().unwrap(); // Safe because validate_log_path guarantees a filename

    // Create directory if it doesn't exist
    if !log_dir.exists() {
        if let Err(e) = std::fs::create_dir_all(log_dir) {
            return Err(LogInitError::DirectoryCreationFailed {
                path: log_dir.display().to_string(),
                source: e,
            });
        }
    }

    // Create daily rotating file appender
    let file_appender = rolling::daily(log_dir, log_file_name);

    // Create non-blocking writer and get the guard
    let (non_blocking_writer, guard) = tracing_appender::non_blocking(file_appender);

    // Create file filter based on config.log_file_level
    let file_filter = match EnvFilter::try_new(&config.log_file_level) {
        Ok(filter) => filter,
        Err(e) => {
            // Return a FilterParseError to make it clear what happened
            return Err(LogInitError::FilterParseError(format!(
                "Failed to parse file log level filter '{}': {}",
                config.log_file_level, e
            )));
        }
    };

    // Create file layer with JSON formatting
    let file_layer = tracing_fmt::layer()
        .json()
        .with_writer(non_blocking_writer)
        .with_filter(file_filter);

    // Create stdout filter based on RUST_LOG or config.log_stdout_level
    let stdout_filter = match EnvFilter::try_from_default_env() {
        Ok(filter) => filter,
        Err(_) => match EnvFilter::try_new(&config.log_stdout_level) {
            Ok(filter) => filter,
            Err(e) => {
                // Return a FilterParseError to make it clear what happened
                return Err(LogInitError::FilterParseError(format!(
                    "Failed to parse stdout log level filter '{}': {}",
                    config.log_stdout_level, e
                )));
            }
        },
    };

    // Create registry and add file layer
    let subscriber = registry().with(file_layer);

    // Add the appropriate stdout layer based on format
    if config.log_format == "json" {
        let json_layer = tracing_fmt::layer()
            .json()
            .with_writer(io::stdout)
            .with_filter(stdout_filter);
        subscriber.with(json_layer).init();
    } else {
        let pretty_layer = tracing_fmt::layer()
            .pretty()
            .with_writer(io::stdout)
            .with_filter(stdout_filter);
        subscriber.with(pretty_layer).init();
    }

    // Log initialization
    info!(
        log_stdout_level = %config.log_stdout_level,
        log_format = %config.log_format,
        log_file_path = %config.log_file_path,
        log_file_level = %config.log_file_level,
        "Dual logging initialized"
    );

    // Return guard to keep it alive
    Ok(guard)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs;
    use tracing::{debug, error, info, warn};

    #[test]
    fn test_environment_detection() {
        // This tests the basic functionality of detect_environment
        // Since we can't easily mock system state, we just ensure it returns a valid variant
        let env = detect_environment();

        // Ensure we get a valid environment variant
        assert!(matches!(
            env,
            LogEnvironment::Development
                | LogEnvironment::UserInstallation
                | LogEnvironment::SystemService
        ));

        // In most test environments, it should detect as Development
        #[cfg(debug_assertions)]
        assert_eq!(env, LogEnvironment::Development);
    }

    #[test]
    fn test_environment_detection_with_dev_env_var() {
        // Set the development environment variable
        env::set_var("SWITCHBOARD_DEV", "1");

        // Should detect as Development when the env var is set
        let env = detect_environment();
        assert_eq!(env, LogEnvironment::Development);

        // Clean up
        env::remove_var("SWITCHBOARD_DEV");
    }

    #[test]
    fn test_dual_output_logging() {
        // Create a test file in the current directory
        let log_file_path = "test_switchboard.log";

        // Create a test configuration
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            log_file_path: log_file_path.to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Initialize logging
        let _guard = init_tracing(&config).expect("Failed to initialize logging");

        // Emit logs at different levels
        debug!("This is a debug message");
        info!("This is an info message");
        warn!("This is a warning message");
        error!("This is an error message");

        // Explicitly drop the guard to flush logs
        drop(_guard);

        // Clean up file after test
        let _ = fs::remove_file(log_file_path);

        // This test simply verifies the dual-output logging initializes properly
        // We don't attempt to verify the content of the logs due to the complexity
        // of capturing and parsing both stdout and file output in a unit test.
        // The real test is that the code doesn't panic or crash.
    }

    #[test]
    fn test_xdg_log_directory() {
        // Just verify that the function returns a non-empty path
        let xdg_dir = get_xdg_log_directory();
        assert!(!xdg_dir.to_string_lossy().is_empty());

        // Verify that the path ends with "logs"
        let path_str = xdg_dir.to_string_lossy();
        assert!(
            path_str.ends_with("logs")
                || path_str.ends_with("logs/")
                || path_str.ends_with("logs\\"),
            "Path should end with 'logs': {}",
            path_str
        );
    }

    #[test]
    fn test_environment_log_directory() {
        // Test Development environment
        let dev_dir = get_environment_log_directory(LogEnvironment::Development);
        assert_eq!(dev_dir, PathBuf::from(DEFAULT_LOG_DIR));

        // Test UserInstallation environment (should use XDG)
        let user_dir = get_environment_log_directory(LogEnvironment::UserInstallation);
        assert_eq!(user_dir, get_xdg_log_directory());

        // Test SystemService environment
        let system_dir = get_environment_log_directory(LogEnvironment::SystemService);
        assert_eq!(system_dir, PathBuf::from(SYSTEM_LOG_DIR));
    }

    #[test]
    fn test_directory_creation_error() {
        // Skip this test on platforms where /proc is not prohibited
        // The path validation would now detect this as a reserved path,
        // so we would get a ReservedSystemPath error before reaching directory creation
        #[cfg(target_family = "unix")]
        {
            // Create a configuration with a path to a location that cannot be created
            let config = Config {
                port: "0".to_string(),
                anthropic_api_key: "test-key".to_string(),
                anthropic_target_url: "https://example.com".to_string(),
                log_stdout_level: "info".to_string(),
                log_format: "pretty".to_string(),
                log_bodies: true,
                // Use a directory that exists but we won't have write permissions to
                // (assuming standard permissions, will need a different approach if running as root)
                log_file_path: "/var/lib/non_existent_dir/test.log".to_string(),
                log_file_level: "debug".to_string(),
                log_max_body_size: 1024,
            };

            // Initialize logging - should return an error
            let result = init_tracing(&config);

            // We'll get either a reserved path error, permission issue, or directory creation failed
            // Any of these are acceptable, based on the exact system permissions
            assert!(matches!(
                result,
                Err(LogInitError::ReservedSystemPath(_))
                    | Err(LogInitError::PermissionIssue { .. })
                    | Err(LogInitError::DirectoryCreationFailed { .. })
            ));
        }

        // On Windows, use a different approach
        #[cfg(target_family = "windows")]
        {
            let config = Config {
                port: "0".to_string(),
                anthropic_api_key: "test-key".to_string(),
                anthropic_target_url: "https://example.com".to_string(),
                log_stdout_level: "info".to_string(),
                log_format: "pretty".to_string(),
                log_bodies: true,
                // Windows equivalent
                log_file_path: "C:\\Windows\\System32\\invalid_dir\\test.log".to_string(),
                log_file_level: "debug".to_string(),
                log_max_body_size: 1024,
            };

            let result = init_tracing(&config);

            assert!(matches!(
                result,
                Err(LogInitError::ReservedSystemPath(_))
                    | Err(LogInitError::PermissionIssue { .. })
                    | Err(LogInitError::DirectoryCreationFailed { .. })
            ));
        }
    }

    #[test]
    fn test_invalid_path_error() {
        // Create a configuration with an invalid path (empty filename)
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,

            // Empty string - should fail validation
            log_file_path: "".to_string(),

            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Initialize logging - should return an error
        let result = init_tracing(&config);

        // Assert that we got the expected error type
        assert!(matches!(result, Err(LogInitError::InvalidPath(_))));
    }

    #[test]
    fn test_filter_parse_error() {
        // Test that the FilterParseError variant can be constructed and matched against
        let error = LogInitError::FilterParseError("Test error message".to_string());

        assert!(matches!(error, LogInitError::FilterParseError(_)));

        // Test that the error message is properly formatted
        if let LogInitError::FilterParseError(msg) = error {
            assert_eq!(msg, "Test error message");
        }

        // Test the Display implementation
        assert_eq!(
            format!(
                "{}",
                LogInitError::FilterParseError("Test error".to_string())
            ),
            "Failed to parse log level filter: Test error"
        );
    }

    // Tests for the path validation function

    #[test]
    fn test_path_validation_success() {
        // Create a temporary directory for testing
        let temp_dir = env::temp_dir().join("switchboard_path_test");
        fs::create_dir_all(&temp_dir).expect("Failed to create temp directory");

        // Typical valid paths that should pass validation
        let valid_paths = [
            temp_dir.join("simple.log").to_string_lossy().to_string(),
            temp_dir
                .join("nested/path/file.log")
                .to_string_lossy()
                .to_string(),
            "relative_path.log".to_string(),
            "./local_dir/file.log".to_string(),
        ];

        for path in valid_paths {
            let result = validate_log_path(&path);
            assert!(result.is_ok(), "Path should be valid: {}", path);
        }

        // Clean up
        let _ = fs::remove_dir_all(temp_dir);
    }

    #[test]
    fn test_path_validation_failures() {
        // Empty path
        assert!(matches!(
            validate_log_path(""),
            Err(LogInitError::InvalidPath(_))
        ));

        // Path traversal attempts
        let traversal_paths = [
            "../etc/passwd",
            "logs/../../../etc/shadow",
            "normal/looking/../../path/file.log",
            "..\\Windows\\System32\\config.sys",
        ];

        for path in traversal_paths {
            let result = validate_log_path(path);
            assert!(
                matches!(result, Err(LogInitError::PathTraversalAttempt(_))),
                "Path traversal should be detected: {}",
                path
            );
        }

        // Directory path test is now different from original
        // Since we now support directory paths, this should not return an error
        // We'll replace this with a different test case
        let result = validate_log_path("/tmp/");
        assert!(result.is_ok(), "Directory path should now be valid: /tmp/");

        // Reserved system paths
        #[cfg(target_family = "unix")]
        {
            // Check if we can actually run the reserved path tests
            // Some CI environments or container setups might not have standard directories
            if Path::new("/bin").exists() && Path::new("/etc").exists() {
                let system_paths = [
                    "/bin/log.txt",
                    "/etc/switchboard.log",
                    "/usr/bin/app.log",
                    "/sbin/temp.log",
                ];

                for path in system_paths {
                    println!("Testing reserved path: {}", path);
                    let result = validate_log_path(path);
                    println!("Result: {:?}", result);

                    // Check for either ReservedSystemPath or PermissionIssue
                    // Either is acceptable, as environments vary
                    assert!(
                        matches!(result, Err(LogInitError::ReservedSystemPath(_)))
                            || matches!(result, Err(LogInitError::PermissionIssue { .. })),
                        "System path should be detected as reserved or permission issue: {}",
                        path
                    );
                }
            }

            // Additional sensitive paths that should always be detected
            let traversal_paths = ["/dev/log.txt", "/proc/logger.log"];

            for path in traversal_paths {
                let result = validate_log_path(path);
                // We'll accept any error here - specific error might depend on system
                assert!(result.is_err(), "System path should be rejected: {}", path);
            }
        }

        #[cfg(target_family = "windows")]
        {
            // Only run these tests if we're on Windows and these directories exist
            if Path::new("C:\\Windows").exists() {
                let system_paths = ["C:\\Windows\\log.txt", "C:\\Program Files\\app.log"];

                for path in system_paths {
                    println!("Testing reserved path: {}", path);
                    let result = validate_log_path(path);
                    println!("Result: {:?}", result);

                    // Check for either ReservedSystemPath or PermissionIssue
                    // Either is acceptable, as environments vary
                    assert!(
                        matches!(result, Err(LogInitError::ReservedSystemPath(_)))
                            || matches!(result, Err(LogInitError::PermissionIssue { .. })),
                        "System path should be detected as reserved or permission issue: {}",
                        path
                    );
                }
            }
        }
    }

    #[test]
    fn test_path_with_root_permission_requirements() {
        // Skip for non-unix as the permission model is different
        #[cfg(target_family = "unix")]
        {
            // Root-owned directories that should fail for non-root users
            // This test assumes it's not being run as root
            let root_paths = [
                // Standard system directories that require root to write to
                "/var/log/switchboard.log",
                "/var/spool/app.log",
            ];

            // Check if we're running as root - if so, skip these tests
            let uid = unsafe { libc::getuid() };
            if uid != 0 {
                for path in root_paths {
                    let result = validate_log_path(path);

                    // Could be either permission issue or reserved path
                    assert!(
                        matches!(
                            result,
                            Err(LogInitError::PermissionIssue { .. })
                                | Err(LogInitError::ReservedSystemPath(_))
                        ),
                        "Path requiring root should be detected: {}",
                        path
                    );
                }
            }
        }
    }

    #[test]
    fn test_log_path_resolver_new() {
        // Create a test configuration
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            log_file_path: "./custom_name.log".to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Create resolvers for both application and test logs
        let app_resolver = LogPathResolver::new(&config, LogType::Application);
        let test_resolver = LogPathResolver::new(&config, LogType::Test);

        // Verify that the file name is correctly extracted from the path
        assert_eq!(app_resolver.file_name, "custom_name.log");
        assert_eq!(test_resolver.file_name, "custom_name.log");

        // Verify that the log types are correctly assigned
        assert_eq!(app_resolver.log_type, LogType::Application);
        assert_eq!(test_resolver.log_type, LogType::Test);

        // Verify base directory is set properly
        // In a test environment, the base_dir should be the DEFAULT_LOG_DIR
        // (The environment is typically detected as Development in tests)
        assert_eq!(app_resolver.base_dir, PathBuf::from(DEFAULT_LOG_DIR));
        assert_eq!(test_resolver.base_dir, PathBuf::from(DEFAULT_LOG_DIR));
    }

    #[test]
    fn test_log_path_resolver_with_absolute_path() {
        // Create a config with absolute path
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            log_file_path: "/tmp/absolute/path/log_file.log".to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Create a resolver
        let resolver = LogPathResolver::new(&config, LogType::Application);

        // Verify that just the filename is extracted, not the path
        assert_eq!(resolver.file_name, "log_file.log");
    }

    #[test]
    fn test_log_path_resolver_with_default_filename() {
        // Create a config with invalid path (to trigger default)
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            // This path has no filename component
            log_file_path: "/".to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Create a resolver
        let resolver = LogPathResolver::new(&config, LogType::Application);

        // Verify that the default filename is used
        assert_eq!(resolver.file_name, "switchboard.log");
    }
    
    #[test]
    fn test_log_path_resolver_resolve() {
        // Create a test configuration
        let config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            log_file_path: "custom.log".to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };

        // Test app log resolution
        let app_resolver = LogPathResolver::new(&config, LogType::Application);
        let app_path = app_resolver.resolve().expect("Failed to resolve app path");
        
        // Verify the app path structure
        assert!(
            app_path.to_string_lossy().contains(APP_LOG_SUBDIR),
            "App path does not contain app subdirectory: {}",
            app_path.display()
        );
        assert!(
            app_path.ends_with("custom.log"),
            "App path does not end with correct filename: {}",
            app_path.display()
        );
        
        // Test test log resolution
        let test_resolver = LogPathResolver::new(&config, LogType::Test);
        let test_path = test_resolver.resolve().expect("Failed to resolve test path");
        
        // Verify the test path structure
        assert!(
            test_path.to_string_lossy().contains(TEST_LOG_SUBDIR),
            "Test path does not contain test subdirectory: {}",
            test_path.display()
        );
        assert!(
            test_path.ends_with("custom.log"),
            "Test path does not end with correct filename: {}",
            test_path.display()
        );
        
        // Verify the directories were created
        let app_dir_path = app_path.parent().unwrap();
        let test_dir_path = test_path.parent().unwrap();
        
        assert!(
            app_dir_path.exists(),
            "App log directory was not created: {}",
            app_dir_path.display()
        );
        assert!(
            test_dir_path.exists(),
            "Test log directory was not created: {}",
            test_dir_path.display()
        );
        
        // On Unix platforms, verify the permissions
        #[cfg(target_family = "unix")]
        {
            use std::os::unix::fs::PermissionsExt;
            
            let app_dir_perms = std::fs::metadata(app_dir_path)
                .expect("Failed to get app directory metadata")
                .permissions()
                .mode();
            let test_dir_perms = std::fs::metadata(test_dir_path)
                .expect("Failed to get test directory metadata")
                .permissions()
                .mode();
            
            // Check that the mode matches 0o750 (rwxr-x---)
            // We use bitwise AND with 0o777 to mask out non-permission bits
            assert_eq!(
                app_dir_perms & 0o777,
                0o750,
                "App directory permissions are incorrect: {:o}",
                app_dir_perms & 0o777
            );
            assert_eq!(
                test_dir_perms & 0o777,
                0o750,
                "Test directory permissions are incorrect: {:o}",
                test_dir_perms & 0o777
            );
        }
    }
    
    #[test]
    fn test_log_path_resolver_resolve_existing_directory() {
        // Create a test directory structure that already exists
        let temp_dir = env::temp_dir().join("switchboard_resolver_test");
        let app_dir = temp_dir.join(APP_LOG_SUBDIR);
        let test_dir = temp_dir.join(TEST_LOG_SUBDIR);
        
        // Create the directories
        std::fs::create_dir_all(&app_dir).expect("Failed to create test app directory");
        std::fs::create_dir_all(&test_dir).expect("Failed to create test test directory");
        
        // This config is not used in this test but kept for context clarity
        let _config = Config {
            port: "0".to_string(),
            anthropic_api_key: "test-key".to_string(),
            anthropic_target_url: "https://example.com".to_string(),
            log_stdout_level: "info".to_string(),
            log_format: "pretty".to_string(),
            log_bodies: true,
            log_file_path: "existing.log".to_string(),
            log_file_level: "debug".to_string(),
            log_max_body_size: 1024,
        };
        
        // Create custom resolvers with our test paths
        let app_resolver = LogPathResolver {
            base_dir: temp_dir.clone(),
            log_type: LogType::Application,
            file_name: "existing.log".to_string(),
        };
        
        let test_resolver = LogPathResolver {
            base_dir: temp_dir.clone(),
            log_type: LogType::Test,
            file_name: "existing.log".to_string(),
        };
        
        // Resolve paths
        let app_path = app_resolver.resolve().expect("Failed to resolve existing app path");
        let test_path = test_resolver.resolve().expect("Failed to resolve existing test path");
        
        // Verify the paths are correct
        assert_eq!(
            app_path,
            app_dir.join("existing.log"),
            "App path does not match expected: {}",
            app_path.display()
        );
        assert_eq!(
            test_path,
            test_dir.join("existing.log"),
            "Test path does not match expected: {}",
            test_path.display()
        );
        
        // Clean up
        std::fs::remove_dir_all(temp_dir).ok();
    }
    
    #[test]
    fn test_log_path_resolver_permission_error() {
        // This test only makes sense on Unix systems where we can set restricted permissions
        #[cfg(target_family = "unix")]
        {
            use std::fs::Permissions;
            use std::os::unix::fs::PermissionsExt;
            
            // Create a temporary directory with restricted permissions
            let temp_dir = env::temp_dir().join("switchboard_restricted_test");
            
            // Create the directory
            std::fs::create_dir_all(&temp_dir).expect("Failed to create test directory");
            
            // Make it read-only (no write access)
            std::fs::set_permissions(&temp_dir, Permissions::from_mode(0o500))
                .expect("Failed to set test directory permissions");
            
            // Skip if we're running as root (permission restrictions won't apply)
            let uid = unsafe { libc::getuid() };
            if uid != 0 {
                // Create a test resolver with the restricted base directory
                let resolver = LogPathResolver {
                    base_dir: temp_dir.clone(),
                    log_type: LogType::Application,
                    file_name: "permission_test.log".to_string(),
                };
                
                // Try to resolve - should fail with permission error when it tries to create subdirectory
                let result = resolver.resolve();
                
                // Verify we get a directory creation error
                assert!(
                    matches!(result, Err(LogInitError::DirectoryCreationFailed { .. })),
                    "Expected DirectoryCreationFailed error, got {:?}",
                    result
                );
            }
            
            // Reset permissions for cleanup
            // Ignoring errors because we expect this to fail on some systems
            let _ = std::fs::set_permissions(&temp_dir, Permissions::from_mode(0o755));
            let _ = std::fs::remove_dir_all(temp_dir);
        }
    }
}
