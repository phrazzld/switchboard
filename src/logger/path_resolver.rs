use crate::config::DEFAULT_LOG_DIRECTORY_MODE;
use crate::fs_utils;
use crate::logger::environment::detect_environment;
use crate::logger::{
    get_environment_log_directory, LogInitError, APP_LOG_SUBDIR, DEFAULT_LOG_DIR, TEST_LOG_SUBDIR,
};
use std::io;
#[cfg(target_family = "unix")]
use std::os::unix::fs::MetadataExt;
use std::path::{Path, PathBuf};
use tracing::error;

/// Type of logs being generated by the application
///
/// This enum distinguishes between application logs (normal operation) and
/// test logs (generated during test runs), allowing them to be stored in
/// separate directories.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[allow(dead_code)]
pub enum LogType {
    /// Normal application logs (production, development)
    Application,
    /// Logs generated during test runs
    Test,
}

/// Resolves log file paths based on environment, configuration, and log type
///
/// This struct is responsible for determining the appropriate log directory
/// and file path based on:
/// - The current execution environment (development, user installation, or system service)
/// - The application configuration
/// - The type of logs being generated (application or test)
///
/// It handles the complexity of organizing logs in a consistent directory structure
/// across different deployment environments, following platform-specific conventions.
#[derive(Debug, Clone)]
pub struct LogPathResolver {
    /// Base directory for logs, determined by environment
    pub(crate) base_dir: PathBuf,
    /// Type of logs (application or test)
    pub(crate) log_type: LogType,
    /// Name of the log file (without directory path)
    pub(crate) file_name: String,
}

impl LogPathResolver {
    /// Creates a new LogPathResolver instance
    ///
    /// Initializes a path resolver based on the current environment and provided configuration.
    /// The resolver will use the appropriate base directory for the detected environment,
    /// and will be configured for either application or test logs.
    ///
    /// # Arguments
    ///
    /// * `config` - Reference to the application configuration
    /// * `log_type` - The type of logs to handle (Application or Test)
    ///
    /// # Returns
    ///
    /// A new LogPathResolver instance configured for the specified log type and
    /// current environment.
    ///
    /// # Examples
    ///
    /// ```
    /// use switchboard::config::{Config, LogDirectoryMode};
    /// use switchboard::logger::{LogPathResolver, LogType};
    /// use secrecy::SecretString;
    ///
    /// // Create a test configuration
    /// let config = Config {
    ///     # openai_api_key: None,
    ///     # openai_api_base_url: "https://api.openai.com".to_string(),
    ///     # openai_enabled: false,
    ///     // ... config fields ...
    ///     log_file_path: "./switchboard.log".to_string(),
    ///     // ... other fields ...
    ///     # port: "8080".to_string(),
    ///     # anthropic_api_key: SecretString::new("test-key".to_string().into()),
    ///     # anthropic_target_url: "https://example.com".to_string(),
    ///     # log_stdout_level: "info".to_string(),
    ///     # log_format: "pretty".to_string(),
    ///     # log_bodies: true,
    ///     # log_file_level: "debug".to_string(),
    ///     # log_max_body_size: 20480,
    ///     # log_directory_mode: LogDirectoryMode::Default,
    ///     # log_max_age_days: None,
    /// };
    ///
    /// // Create a resolver for application logs
    /// let app_resolver = LogPathResolver::new(&config, LogType::Application);
    /// ```
    pub fn new(config: &crate::config::Config, log_type: LogType) -> Self {
        // Check if the provided path is a legacy path (used for debugging and logging)
        // The variable is intentionally unused here but the check is useful for debugging
        let _is_legacy = Self::is_legacy_path(&config.log_file_path);

        // Detect the current environment
        let environment = detect_environment();

        // Get the appropriate base directory for this environment
        let base_dir = get_environment_log_directory(environment);

        // Extract just the filename from the configured log path
        let file_name = Path::new(&config.log_file_path)
            .file_name()
            .map(|name| name.to_string_lossy().to_string())
            .unwrap_or_else(|| "switchboard.log".to_string());

        LogPathResolver {
            base_dir,
            log_type,
            file_name,
        }
    }

    /// Detects if a path is in legacy format
    ///
    /// Legacy paths are those that don't conform to the new directory structure,
    /// such as paths that:
    /// - Don't use the new logs/app or logs/test subdirectories
    /// - Use old hardcoded locations
    /// - Don't follow environment-specific conventions
    ///
    /// # Arguments
    ///
    /// * `path` - The path string to check
    ///
    /// # Returns
    ///
    /// `true` if the path is detected as a legacy path, `false` otherwise
    pub fn is_legacy_path(path: &str) -> bool {
        // Check for paths that directly match the new directory patterns

        // Check for app subdirectory with correct structure
        let app_pattern_unix = format!("{}/{}/", DEFAULT_LOG_DIR, APP_LOG_SUBDIR);
        let app_pattern_windows = format!("{}\\{}\\/", DEFAULT_LOG_DIR, APP_LOG_SUBDIR);
        let path_contains_app_subdir =
            path.contains(&app_pattern_unix) || path.contains(&app_pattern_windows);

        // Check for test subdirectory with correct structure
        let test_pattern_unix = format!("{}/{}/", DEFAULT_LOG_DIR, TEST_LOG_SUBDIR);
        let test_pattern_windows = format!("{}\\{}\\/", DEFAULT_LOG_DIR, TEST_LOG_SUBDIR);
        let path_contains_test_subdir =
            path.contains(&test_pattern_unix) || path.contains(&test_pattern_windows);

        // Check for XDG paths (simplified check for the most common patterns)
        let path_contains_xdg_pattern = path.contains(".local/share/switchboard/logs") ||    // Linux
                                       path.contains("Library/Application Support/switchboard/logs") || // macOS
                                       path.contains("AppData\\Roaming\\switchboard\\logs"); // Windows

        // Check for system paths
        let path_contains_system_pattern = path.contains(crate::logger::SYSTEM_LOG_DIR);

        // Special case - check for logs/app/ or logs/test/ patterns more generically
        // This helps catch paths that might use the right structure with different base paths
        let generic_app_pattern = format!("logs/{}/", APP_LOG_SUBDIR);
        let generic_test_pattern = format!("logs/{}/", TEST_LOG_SUBDIR);
        let path_contains_generic_pattern =
            path.contains(&generic_app_pattern) || path.contains(&generic_test_pattern);

        // A path is legacy if it doesn't match any of the new directory patterns
        !(path_contains_app_subdir
            || path_contains_test_subdir
            || path_contains_xdg_pattern
            || path_contains_system_pattern
            || path_contains_generic_pattern)
    }

    /// Resolves the complete log file path and creates necessary directories
    ///
    /// This method:
    /// 1. Constructs the full path by combining:
    ///    - Base directory (determined by environment)
    ///    - Subdirectory (app/ or test/ based on log type)
    ///    - Filename
    /// 2. Creates the directory structure if it doesn't exist
    /// 3. Sets appropriate permissions based on platform
    ///
    /// If the original path is detected as a legacy path, a warning is logged.
    ///
    /// # Returns
    ///
    /// * `Ok(PathBuf)` - The resolved absolute path if everything succeeds
    /// * `Err(LogInitError)` - Error details if directory creation or permission setting fails
    ///
    /// # Examples
    ///
    /// ```
    /// use switchboard::config::{Config, LogDirectoryMode};
    /// use switchboard::logger::{LogPathResolver, LogType};
    /// use secrecy::SecretString;
    ///
    /// // Create a test configuration
    /// let config = Config {
    ///     # openai_api_key: None,
    ///     # openai_api_base_url: "https://api.openai.com".to_string(),
    ///     # openai_enabled: false,
    ///     // ... config fields ...
    ///     log_file_path: "./switchboard.log".to_string(),
    ///     // ... other fields ...
    ///     # port: "8080".to_string(),
    ///     # anthropic_api_key: SecretString::new("test-key".to_string().into()),
    ///     # anthropic_target_url: "https://example.com".to_string(),
    ///     # log_stdout_level: "info".to_string(),
    ///     # log_format: "pretty".to_string(),
    ///     # log_bodies: true,
    ///     # log_file_level: "debug".to_string(),
    ///     # log_max_body_size: 20480,
    ///     # log_directory_mode: LogDirectoryMode::Default,
    ///     # log_max_age_days: None,
    /// };
    ///
    /// // Create a resolver for application logs and resolve the path
    /// let app_resolver = LogPathResolver::new(&config, LogType::Application);
    /// let app_log_path = app_resolver.resolve().expect("Failed to resolve log path");
    /// println!("App logs will be stored at: {}", app_log_path.display());
    /// ```
    pub fn resolve(&self) -> Result<PathBuf, LogInitError> {
        // Check if the original path is a legacy path
        let is_legacy = Self::is_legacy_path(&self.file_name);

        // Determine the appropriate subdirectory based on log type
        let subdir = match self.log_type {
            LogType::Application => APP_LOG_SUBDIR,
            LogType::Test => TEST_LOG_SUBDIR,
        };

        // Construct the directory path by combining base dir and subdirectory
        let dir_path = self.base_dir.join(subdir);

        // Create the directory with appropriate permissions if it doesn't exist
        if !dir_path.exists() {
            if let Err(e) = fs_utils::ensure_directory(&dir_path, Some(DEFAULT_LOG_DIRECTORY_MODE))
            {
                // Get information for logging before we move the error
                let error_kind = e.kind();
                let error_display = e.to_string();
                let path_display = dir_path.display().to_string();

                // Log the error before returning
                error!(
                    error_kind = ?error_kind,
                    path = %path_display,
                    error = %error_display,
                    "Failed to create log directory"
                );

                // Map the error to appropriate LogInitError variants
                let log_error = match error_kind {
                    io::ErrorKind::PermissionDenied => LogInitError::PermissionDenied {
                        path: path_display,
                        source: e,
                    },
                    io::ErrorKind::AlreadyExists => LogInitError::DirectoryCreationFailed {
                        path: path_display,
                        source: e,
                    },
                    // Map any other IO errors to DirectoryCreationFailed
                    _ => LogInitError::DirectoryCreationFailed {
                        path: path_display,
                        source: e,
                    },
                };

                return Err(log_error);
            }
        } else {
            // Directory exists, but verify it's writable
            if let Err(e) = fs_utils::check_writable(&dir_path) {
                // Get information for logging before we move the error
                let error_kind = e.kind();
                let error_display = e.to_string();
                let path_display = dir_path.display().to_string();

                // Log the error before returning
                error!(
                    error_kind = ?error_kind,
                    path = %path_display,
                    error = %error_display,
                    "Existing log directory is not writable"
                );

                // Map the error to appropriate LogInitError variants
                let log_error = match error_kind {
                    io::ErrorKind::PermissionDenied => LogInitError::PermissionDenied {
                        path: path_display,
                        source: e,
                    },
                    _ => LogInitError::PermissionIssue {
                        path: path_display,
                        reason: format!("Directory exists but is not writable: {}", error_display),
                    },
                };

                return Err(log_error);
            }
        }

        // Combine directory path with filename to get the full path
        let file_path = dir_path.join(&self.file_name);

        // If we detected a legacy path, log a warning about it
        if is_legacy {
            // We use eprintln here because normal logging might not be initialized yet
            // This ensures the warning is visible even during initialization
            eprintln!(
                "WARNING: Legacy log path detected: '{}'. It will be stored at '{}' instead. \
                 Please update your configuration to use the new directory structure.",
                self.file_name,
                file_path.display()
            );

            // Once logging is established, this will be available in the logs too
            if let Ok(metadata) = std::fs::metadata(&dir_path) {
                if metadata.is_dir() {
                    tracing::warn!(
                        legacy_path = %self.file_name,
                        new_path = %file_path.display(),
                        "Legacy log path detected - using new directory structure. \
                         Please update your configuration."
                    );
                }
            }
        }

        // Return the resolved path
        Ok(file_path)
    }
}

/// Validate a log file path for security and usability concerns, creating directories as needed
///
/// This function performs comprehensive validation on a log file path to ensure it:
/// - Does not contain path traversal attempts
/// - Is not a reserved system path
/// - Has appropriate permissions for logging
/// - Can be canonicalized to an absolute path
/// - Creates required directory structure if it doesn't exist
///
/// The function now supports the new directory structure using `DEFAULT_LOG_DIR` and the
/// appropriate subdirectory (`APP_LOG_SUBDIR` or `TEST_LOG_SUBDIR`).
///
/// # Arguments
/// * `path_str` - The string path to validate, can be a file or directory path
///
/// # Returns
/// * `Ok(PathBuf)` - The canonicalized absolute path if validation passes
/// * `Err(LogInitError)` - Specific error if validation fails
///
/// # Security Considerations
/// This validation helps prevent common security issues:
/// - Path traversal: Prevents writing to unexpected locations via `../` sequences
/// - System path protection: Prevents overwriting system files in locations like `/bin`, `/etc`, etc.
/// - Permission verification: Ensures logs can actually be written
///
/// # Errors
/// Returns detailed error types for different validation failures:
/// - `LogInitError::InvalidPath` - Path is empty or has invalid format
/// - `LogInitError::PathTraversalAttempt` - Path contains `../` sequences
/// - `LogInitError::ReservedSystemPath` - Path points to a reserved system directory
/// - `LogInitError::PermissionIssue` - Directory exists but is not writable
/// - `LogInitError::PathCanonicalizationError` - Path cannot be canonicalized
/// - `LogInitError::DirectoryCreationFailed` - Directory structure couldn't be created
///
/// # Examples
///
/// ```
/// # use switchboard::logger::validate_log_path;
/// // Valid path in a temporary directory
/// let valid_path = std::env::temp_dir().join("app.log").to_string_lossy().to_string();
/// assert!(validate_log_path(&valid_path).is_ok());
///
/// // Invalid path (path traversal attempt)
/// let invalid_path = "../etc/passwd";
/// assert!(validate_log_path(invalid_path).is_err());
/// ```
#[allow(dead_code)]
pub fn validate_log_path(path_str: &str) -> Result<PathBuf, LogInitError> {
    // Check for empty path
    if path_str.is_empty() {
        return Err(LogInitError::InvalidPath(
            "Log file path cannot be empty".to_string(),
        ));
    }

    let path = Path::new(path_str);

    // Check if path contains parent directory components that could lead to traversal
    if path_str.contains("../") || path_str.contains("..\\") {
        return Err(LogInitError::PathTraversalAttempt(format!(
            "Path contains parent directory traversal sequences: {}",
            path_str
        )));
    }

    // Determine if this is a directory path or a file path
    let is_directory_path = path_str.ends_with('/') || path_str.ends_with('\\');

    // If it's a directory path, we'll use it directly for directory checks
    // If it's a file path, we'll extract the directory and filename separately
    let (dir_path, file_name_opt) = if is_directory_path {
        // For directory paths, we use the path directly and have no filename
        (path, None)
    } else {
        // For file paths, extract filename and directory separately
        let file_name = match path.file_name() {
            Some(name) => name,
            None => {
                return Err(LogInitError::InvalidPath(format!(
                    "Invalid log file path (no filename): {}",
                    path_str
                )));
            }
        };

        // Get directory component
        let dir_path = path.parent().unwrap_or_else(|| Path::new("."));
        (dir_path, Some(file_name))
    };

    // Reserved system paths that should not be used for logging
    let reserved_paths = [
        #[cfg(target_family = "unix")]
        "/bin",
        #[cfg(target_family = "unix")]
        "/sbin",
        #[cfg(target_family = "unix")]
        "/usr/bin",
        #[cfg(target_family = "unix")]
        "/usr/sbin",
        #[cfg(target_family = "unix")]
        "/etc",
        #[cfg(target_family = "unix")]
        "/dev",
        #[cfg(target_family = "unix")]
        "/proc",
        #[cfg(target_family = "unix")]
        "/sys",
        #[cfg(target_family = "windows")]
        "C:\\Windows",
        #[cfg(target_family = "windows")]
        "C:\\Program Files",
        #[cfg(target_family = "windows")]
        "C:\\Program Files (x86)",
    ];

    // Try to canonicalize the path to resolve any . or .. components
    let canonical_path = match std::fs::canonicalize(dir_path) {
        Ok(p) => p,
        Err(e) => {
            // If the directory doesn't exist yet, that's ok - we'll create it later
            // Only return an error if it's not a NotFound error
            if e.kind() != io::ErrorKind::NotFound {
                return Err(LogInitError::PathCanonicalizationError {
                    path: dir_path.display().to_string(),
                    source: e,
                });
            }
            // For NotFound, we'll continue with the original path
            dir_path.to_path_buf()
        }
    };

    // Check if the path (without canonicalization) is a reserved system path
    // This is to catch paths that might not be able to be canonicalized
    let path_to_check = if canonical_path == dir_path.to_path_buf() {
        // If canonicalization didn't work (e.g., directory doesn't exist yet),
        // check the original path against reserved paths
        path_str.to_string()
    } else {
        // Otherwise, check the canonical path
        canonical_path.to_string_lossy().to_string()
    };

    for reserved in &reserved_paths {
        if path_to_check.starts_with(reserved) {
            return Err(LogInitError::ReservedSystemPath(format!(
                "Path '{}' is within a reserved system directory: {}",
                path_str, reserved
            )));
        }
    }

    // If base directory doesn't exist, create the needed structure
    let base_dir = if path_str.starts_with(DEFAULT_LOG_DIR) {
        PathBuf::from(DEFAULT_LOG_DIR)
    } else if path_str.contains(DEFAULT_LOG_DIR) {
        // This handles more complex paths that might include the default directory somewhere
        let parts: Vec<_> = path_str.split(DEFAULT_LOG_DIR).collect();
        if parts.len() >= 2 {
            PathBuf::from(format!("{}{}", parts[0], DEFAULT_LOG_DIR))
        } else {
            PathBuf::from(DEFAULT_LOG_DIR)
        }
    } else {
        // For paths that don't include our default directory, we'll just focus on the provided directory
        PathBuf::new()
    };

    // If we identified a valid base directory and it doesn't exist, create it
    if !base_dir.as_os_str().is_empty() && !base_dir.exists() {
        if let Err(e) = std::fs::create_dir_all(&base_dir) {
            return Err(LogInitError::DirectoryCreationFailed {
                path: base_dir.display().to_string(),
                source: e,
            });
        }
    }

    // Check for and create the app/test subdirectories if needed
    if base_dir.as_os_str().is_empty() {
        // No base directory was identified, so we can't create subdirectories
    } else if path_str.contains(APP_LOG_SUBDIR) {
        // Path contains app subdirectory
        let app_dir = base_dir.join(APP_LOG_SUBDIR);
        if !app_dir.exists() {
            if let Err(e) = std::fs::create_dir_all(&app_dir) {
                return Err(LogInitError::DirectoryCreationFailed {
                    path: app_dir.display().to_string(),
                    source: e,
                });
            }
        }
    } else if path_str.contains(TEST_LOG_SUBDIR) {
        // Path contains test subdirectory
        let test_dir = base_dir.join(TEST_LOG_SUBDIR);
        if !test_dir.exists() {
            if let Err(e) = std::fs::create_dir_all(&test_dir) {
                return Err(LogInitError::DirectoryCreationFailed {
                    path: test_dir.display().to_string(),
                    source: e,
                });
            }
        }
    }

    // If directory exists, check permissions
    if dir_path.exists() {
        // Try to check if we can write to this directory
        match std::fs::metadata(dir_path) {
            Ok(metadata) => {
                #[cfg(target_family = "unix")]
                {
                    // On Unix systems, check if directory is writable by the current user
                    let dir_mode = metadata.mode();
                    let uid = unsafe { libc::getuid() };
                    let gid = unsafe { libc::getgid() };

                    let owner_writable = (dir_mode & 0o200) != 0; // Check owner write permission
                    let group_writable = (dir_mode & 0o020) != 0; // Check group write permission
                    let world_writable = (dir_mode & 0o002) != 0; // Check world write permission

                    let is_owner = metadata.uid() == uid;
                    let is_group = metadata.gid() == gid;

                    let is_writable = (is_owner && owner_writable)
                        || (is_group && group_writable)
                        || world_writable;

                    if !is_writable {
                        return Err(LogInitError::PermissionIssue {
                            path: dir_path.display().to_string(),
                            reason: "Directory is not writable by the current user".to_string(),
                        });
                    }
                }

                // For other platforms, we'll try a more basic approach
                #[cfg(not(target_family = "unix"))]
                {
                    // Check if readonly
                    if metadata.permissions().readonly() {
                        return Err(LogInitError::PermissionIssue {
                            path: dir_path.display().to_string(),
                            reason: "Directory is read-only".to_string(),
                        });
                    }
                }
            }
            Err(e) => {
                // If we can't read metadata, that might be a permissions issue
                return Err(LogInitError::PermissionIssue {
                    path: dir_path.display().to_string(),
                    reason: format!("Failed to read directory metadata: {}", e),
                });
            }
        }
    } else if !is_directory_path {
        // If it's a file path and the parent directory doesn't exist, create it
        if let Err(e) = std::fs::create_dir_all(dir_path) {
            return Err(LogInitError::DirectoryCreationFailed {
                path: dir_path.display().to_string(),
                source: e,
            });
        }
    }

    // Construct the final path
    let result_path = if is_directory_path {
        // For directory paths, just use the canonical path directly
        canonical_path
    } else {
        // For file paths, combine canonical directory path with filename
        let mut path = canonical_path;
        if let Some(file_name) = file_name_opt {
            path.push(file_name);
        }
        path
    };

    Ok(result_path)
}
